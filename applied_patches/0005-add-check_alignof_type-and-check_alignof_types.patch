From 91f094ea5c6269b73b7c9d93204f52c8defcfeb1 Mon Sep 17 00:00:00 2001
From: Jens Rehsack <sno@NetBSD.org>
Date: Fri, 27 Jan 2012 15:36:28 +0100
Subject: [PATCH 5/5] add check_alignof_type() and check_alignof_types()

---
 Changes                |    2 +
 lib/Config/AutoConf.pm |  102 ++++++++++++++++++++++++++++++++++++++++++++++++
 t/02.compile.t         |   14 +++++-
 3 files changed, 115 insertions(+), 3 deletions(-)

diff --git a/Changes b/Changes
index e686cc5..a040fc6 100644
--- a/Changes
+++ b/Changes
@@ -12,6 +12,8 @@ Revision history for Config-AutoConf
 	 check_sizeof_type
 	 check_sizeof_types
 	 compute_int
+	 check_alignof_type
+	 check_alignof_types
 
 0.17    Jan  4, 2011
         - Re-fixed tests that do not run in <= v5.010
diff --git a/lib/Config/AutoConf.pm b/lib/Config/AutoConf.pm
index 885814d..c6eb9f1 100644
--- a/lib/Config/AutoConf.pm
+++ b/lib/Config/AutoConf.pm
@@ -1168,6 +1168,108 @@ sub check_sizeof_types {
   return $have_sizes;
 }
 
+sub _alignof_type_define_name {
+  my $type = $_[0];
+  my $have_name = "ALIGNOF_" . uc($type);
+  $have_name =~ tr/*/P/;
+  $have_name =~ tr/_A-Za-z0-9/_/c;
+  return $have_name;
+}
+
+=head2 check_alignof_type (type, [action-if-found], [action-if-not-found], [prologue = default includes])
+
+Define ALIGNOF_type to be the alignment in bytes of type. I<type y;> must
+be valid as a structure member declaration or I<type> must be a structure
+member itself.
+
+This method caches its result in the C<ac_cv_alignof_E<lt>set langE<gt>>_type
+variable, with I<*> mapped to C<p> and other characters not suitable for a
+variable name mapped to underscores.
+
+=cut
+
+sub check_alignof_type {
+  my ($self, $type, $action_if_found, $action_if_not_found, $prologue) = @_;
+  $self = $self->_get_instance();
+  defined( $type ) or return; # XXX prefer croak
+  ref( $type ) eq "" or return;
+
+  my $cache_name = $self->_cache_type_name( "alignof", $self->{lang}, $type );
+  my $check_sub = sub {
+
+    my @decls = (
+      "#ifndef offsetof",
+      "# ifdef __ICC",
+      "#  define offsetof(type,memb) ((size_t)(((char *)(&((type*)0)->memb)) - ((char *)0)))",
+      "# else",
+      "#  define offsetof(type,memb) ((size_t)&((type*)0)->memb)",
+      "# endif",
+      "#endif"
+    );
+
+    my ($struct, $memb);
+    if( $type =~ m/^([^.]+)\.([^.]+)$/ ) {
+      $struct = $1;
+      $memb = $2;
+    }
+    else {
+      push( @decls, "typedef struct { char x; $type y; } ac__type_alignof_;" );
+      $struct = "ac__type_alignof_";
+      $memb = "y";
+    }
+  
+    my $typealign = $self->_compute_int_compile( "offsetof($struct, $memb)", $prologue, @decls );
+    $self->define_var( _alignof_type_define_name( $type ), $typealign ? $typealign : undef, "defined when alignof($type) is available" );
+    if( $typealign ) {
+      if( defined( $action_if_found ) and "CODE" eq ref( $action_if_found ) ) {
+	&{$action_if_found}();
+      }
+    }
+    else {
+      if( defined( $action_if_not_found ) and "CODE" eq ref( $action_if_not_found ) ) {
+	&{$action_if_not_found}();
+      }
+    }
+
+    return $typealign;
+  };
+
+  return $self->check_cached( $cache_name, "for align of $type", $check_sub );
+}
+
+=head2 check_alignof_types (type, [action-if-found], [action-if-not-found], [prologue = default includes])
+
+For each type L<check_alignof_type> is called to check for align of type.
+
+If I<action-if-found> is given, it is additionally executed when all of the
+aligns of the types could determined. If I<action-if-not-found> is given, it
+is executed when one align of the types could not determined.
+
+=cut
+
+sub check_alignof_types {
+  my ($self, $types, $action_if_found, $action_if_not_found, $prologue) = @_;
+  $self = $self->_get_instance();
+
+  my $have_aligns = 1;
+  foreach my $type (@$types) {
+    $have_aligns &= ! ! ($self->check_alignof_type ( $type, undef, undef, $prologue ));
+  }
+
+  if( $have_aligns ) {
+    if( defined( $action_if_found ) and "CODE" eq ref( $action_if_found ) ) {
+      &{$action_if_found}();
+    }
+  }
+  else {
+    if( defined( $action_if_not_found ) and "CODE" eq ref( $action_if_not_found ) ) {
+      &{$action_if_not_found}();
+    }
+  }
+
+  return $have_aligns;
+}
+
 sub _have_member_define_name {
   my $member = $_[0];
   my $have_name = "HAVE_" . uc($member);
diff --git a/t/02.compile.t b/t/02.compile.t
index 3bee9cc..61facb7 100644
--- a/t/02.compile.t
+++ b/t/02.compile.t
@@ -1,6 +1,6 @@
 # -*- cperl -*-
 
-use Test::More tests => 21;
+use Test::More tests => 24;
 
 use Config::AutoConf;
 
@@ -59,8 +59,8 @@ ok $ac->check_types( ["SV *", "AV *", "HV *" ], undef, undef, $include_perl ),
 my $typesize = $ac->check_sizeof_type( "I32", undef, undef, $include_perl );
 ok $typesize, "I32 has size of " . ($typesize ? $typesize : "n/a") . " bytes";
 
-ok $ac->check_sizeof_types( ["I32", "SV *", "AV *", "HV *", "SV.sv_refcnt" ], undef, undef, $include_perl ),
-  "Could determined sizes for I32, SV *, AV *, HV *, SV.sv_refcnt" ;
+ok $ac->check_sizeof_types( ["I32", "SV *", "AV", "HV *", "SV.sv_refcnt" ], undef, undef, $include_perl ),
+  "Could determined sizes for I32, SV *, AV, HV *, SV.sv_refcnt" ;
 
 my $compute = $ac->compute_int( "-sizeof(I32)", undef, $include_perl );
 ok $typesize + $compute == 0, "Compute (-sizeof(I32)";
@@ -73,6 +73,14 @@ ok $ac->check_members( ["struct hv.sv_any", "struct STRUCT_SV.sv_any"],
                        undef, undef, $include_perl ),
   "have struct hv.sv_any and struct STRUCT_SV.sv_any members";
 
+# check aligning
+ok $ac->check_alignof_type( "I32", undef, undef, $include_perl ),
+  "Align of I32";
+ok $ac->check_alignof_type( "SV.sv_refcnt", undef, undef, $include_perl ),
+  "Align of SV.sv_refcnt";
+ok $ac->check_alignof_types( ["I32", "U32", "AV", "HV *", "SV.sv_refcnt" ], undef, undef, $include_perl ),
+  "Could determined sizes for I32, U32, AV, HV *, SV.sv_refcnt" ;
+
 Config::AutoConf->write_config_h();
 ok( -f "config.h", "default config.h created" );
 my $fsize;
-- 
1.7.7.2

